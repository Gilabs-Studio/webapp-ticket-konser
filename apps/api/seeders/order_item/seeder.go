package orderitem

import (
	"log"
	"time"

	"github.com/gilabs/webapp-ticket-konser/api/internal/database"
	"github.com/gilabs/webapp-ticket-konser/api/internal/domain/order"
	orderitem "github.com/gilabs/webapp-ticket-konser/api/internal/domain/order_item"
	ticketcategory "github.com/gilabs/webapp-ticket-konser/api/internal/domain/ticket_category"
)

// Seed seeds order item (ticket) data
// This function uses upsert logic: creates order items if not exists, skips if exists
// Requires: Orders and Ticket Categories must be seeded first
// Only creates tickets for PAID orders
func Seed() error {
	log.Println("Seeding order items (tickets)...")

	// Get all PAID orders
	var paidOrders []order.Order
	if err := database.DB.Where("payment_status = ?", order.PaymentStatusPaid).
		Find(&paidOrders).Error; err != nil {
		return err
	}

	if len(paidOrders) == 0 {
		log.Println("⚠️  [Order Item Seeder] No PAID orders found, skipping order item seeding...")
		log.Println("⚠️  [Order Item Seeder] Please seed orders with PAID status first")
		return nil
	}

	// Use upsert logic: create if not exists, skip if exists
	// Check if order items already exist
	var existingCount int64
	database.DB.Model(&orderitem.OrderItem{}).Count(&existingCount)
	if existingCount > 0 {
		log.Printf("[Order Item Seeder] Order items already exist (%d items), skipping...", existingCount)
		return nil
	}

	createdCount := 0

	// For each PAID order, create order items (tickets)
	for _, o := range paidOrders {
		// Get the event ID from the order's schedule
		var schedule struct {
			ID      string
			EventID string
		}
		if err := database.DB.Table("schedules").
			Select("id, event_id").
			Where("id = ?", o.ScheduleID).
			First(&schedule).Error; err != nil {
			log.Printf("⚠️  [Order Item Seeder] Schedule not found for order %s, skipping...", o.OrderCode)
			continue
		}

		// Get ticket categories for this event
		var categories []ticketcategory.TicketCategory
		if err := database.DB.Where("event_id = ?", schedule.EventID).
			Find(&categories).Error; err != nil {
			log.Printf("⚠️  [Order Item Seeder] Failed to get ticket categories for order %s: %v", o.OrderCode, err)
			continue
		}

		if len(categories) == 0 {
			log.Printf("⚠️  [Order Item Seeder] No ticket categories found for order %s, skipping...", o.OrderCode)
			continue
		}

		// Create order items based on order total amount
		// Distribute tickets across available categories
		// For simplicity, we'll create 1-3 tickets per order based on total amount
		ticketsToCreate := calculateTicketCount(o.TotalAmount, categories)

		for i := 0; i < ticketsToCreate; i++ {
			// Select category in round-robin fashion
			categoryIndex := i % len(categories)
			category := categories[categoryIndex]

			// Create order item
			orderItem := &orderitem.OrderItem{
				OrderID:    o.ID,
				CategoryID: category.ID,
				Status:     orderitem.TicketStatusPaid, // Set as PAID since order is PAID
				CreatedAt:  time.Now().Add(-time.Duration(createdCount) * time.Minute),
				UpdatedAt:  time.Now().Add(-time.Duration(createdCount) * time.Minute),
			}

			// QR code will be auto-generated by BeforeCreate hook
			if err := database.DB.Create(orderItem).Error; err != nil {
				log.Printf("⚠️  [Order Item Seeder] Failed to create order item for order %s: %v", o.OrderCode, err)
				continue
			}

			log.Printf("[Order Item Seeder] ✅ Created ticket: %s (Order: %s, Category: %s, Status: %s)",
				orderItem.QRCode, o.OrderCode, category.CategoryName, orderItem.Status)
			createdCount++
		}

		log.Printf("[Order Item Seeder] ✅ Created %d tickets for order %s", ticketsToCreate, o.OrderCode)
	}

	log.Printf("[Order Item Seeder] Order items seeded successfully. Created: %d tickets", createdCount)
	return nil
}

// calculateTicketCount calculates how many tickets to create based on order total amount
// This is a simple heuristic: more expensive orders get more tickets
func calculateTicketCount(totalAmount float64, categories []ticketcategory.TicketCategory) int {
	if len(categories) == 0 {
		return 1
	}

	// Calculate average category price
	var totalPrice float64
	for _, cat := range categories {
		totalPrice += cat.Price
	}
	avgPrice := totalPrice / float64(len(categories))

	// Create 1-3 tickets based on order amount
	// If order amount is less than 2x average price, create 1 ticket
	// If order amount is 2-4x average price, create 2 tickets
	// If order amount is more than 4x average price, create 3 tickets
	if totalAmount < avgPrice*2 {
		return 1
	} else if totalAmount < avgPrice*4 {
		return 2
	}
	return 3
}

