---
alwaysApply: true
---
Project Standards (Folder Structure, Types, State, Hooks, Services, Components, Suspense)

Technology baseline
- Use Next.js 16 (App Router, Server Components, Server Actions). Prefer route-level `loading.tsx`/`error.tsx`, cache-aware data fetching, and `Suspense` per guidance below. See `https://nextjs.org/blog/next-16`.
- Use Tailwind CSS v4. Simplified setup with `@import "tailwindcss"`, automatic content detection, and modern CSS features. See `https://tailwindcss.com/blog/tailwindcss-v4`.
- Use Zod for schema validation and React Hook Form for form handling. Always use `@hookform/resolvers` to integrate Zod with RHF.
- Use TanStack Query for server state management (API data, caching, refetching).
- **CRITICAL**: Never use `any` type. Always define proper types or use `unknown` with type guards.

Folder structure (per feature)
- Place features under `apps/web/src/features/<featureName>/`:
  - `types/` — only type declarations. Prefer `index.d.ts` or topic-based `*.d.ts`.
  - `schemas/` — Zod schemas for validation. One schema file per form/validation concern (e.g., `login.schema.ts`, `user.schema.ts`).
  - `stores/` — Zustand state. One store per domain, named `use<Domain>Store.ts`.
  - `hooks/` — feature-scoped React hooks, named `use<Thing>.ts`. Use hooks to encapsulate business logic, NOT in components.
  - `services/` — API/side-effects. One module per remote domain.
  - `components/` — UI components. Keep small, focused, and reusable.
    - **CRITICAL**: Never mix business logic with UI components. Components should only handle presentation and user interaction.
    - Use hooks to extract business logic from components.
    - Example: `login-form.tsx` should use `useLogin` hook, not directly call store/service.

Types
- Use `.d.ts` for ambient/shared declarations inside `types/`.
- Export DTOs and domain types from `types/` and import everywhere else.
- Never import React or runtime code inside `.d.ts` files.

Schemas (`schemas/`)
- File name: `<feature>.schema.ts` (e.g., `login.schema.ts`, `user.schema.ts`).
- Export Zod schema and inferred TypeScript type: `export const loginSchema = z.object({...})` and `export type LoginFormData = z.infer<typeof loginSchema>`.
- Keep schemas focused on single validation concern.
- Use for both client-side (React Hook Form) and can be shared with backend validation.

Zustand stores (`stores/`)
- File name: `use<Domain>Store.ts`. Export the hook as default or named.
- Keep state minimal: persist only necessary primitives/ids; derive the rest in selectors.
- Use slices for complex domains; colocate actions with their slice.
- If persistence is required, isolate it (e.g., middleware) and document keys.
- **CRITICAL**: Stores should NOT contain business logic. They only manage state. Business logic goes in hooks or services.

Hooks (`hooks/`)
- Prefix with `use`. One responsibility per hook. SSR-safe by default.
- **CRITICAL**: Extract business logic from components into hooks.
- Example: `useLogin` hook should handle form submission, error handling, navigation - NOT in component.
- Do not reach into stores from hooks unless the hook's purpose is state access.
- Side-effects live in hooks; UI logic (presentation, styling) lives in components.
- Hooks can call services and update stores, but components should call hooks, not services/stores directly.

Services (`services/`)
- Isolate all network calls. No UI/state code.
- Return typed results (DTOs → map to domain types as needed).
- Centralize endpoints/constants. Handle errors close to the edge; throw typed errors.
- Services should match API response format (with `success`, `data`, `error` wrapper).

Components (`components/`)
- **CRITICAL**: Components must be separated by concern:
  - **UI Components** (`ui/`): Pure presentation, no business logic, no state management.
  - **Container Components**: Wire hooks/stores to UI, but logic should be in hooks.
  - **Feature Components**: Combine UI + containers, but delegate logic to hooks.
- Prefer controlled, stateless components. Accept props; avoid hidden state.
- **NEVER** put business logic directly in components. Always extract to hooks.
- Example separation:
  - `login-form.tsx` (UI) → `useLogin` hook (logic) → `authService` (API) → `useAuthStore` (state)
- Keep feature components inside the feature; only promote to `shared/` when reused broadly.

UI/UX Safety Guidelines (CRITICAL - Must Follow)
- **CRITICAL**: All components MUST implement comprehensive safety checks to prevent runtime errors and provide good UX.

1. **Null Safety for Nested Properties**
   - **ALWAYS** use optional chaining (`?.`) when accessing nested object properties.
   - **ALWAYS** provide fallback values using nullish coalescing (`??`) or default values.
   - **NEVER** access properties like `obj.nested.property` without checking if `obj.nested` exists first.
   
   ❌ BAD:
   ```tsx
   <div>{user.profile.name}</div>  // Crashes if user.profile is undefined
   <div>{deal.account.name}</div>  // Crashes if deal.account is undefined
   ```
   
   ✅ GOOD:
   ```tsx
   <div>{user.profile?.name ?? "Unknown User"}</div>
   <div>{deal.account?.name ?? t("unknownAccount")}</div>
   
   // Or extract with defaults:
   const accountName = deal.account?.name ?? t("unknownAccount");
   <div>{accountName}</div>
   ```

2. **Array Safety**
   - **ALWAYS** check array existence and length before mapping/iterating.
   - **ALWAYS** provide empty state UI when arrays are empty.
   - Use `Array.isArray()` if the data might not be an array.
   
   ❌ BAD:
   ```tsx
   {items.map(item => <div key={item.id}>{item.name}</div>)}  // Crashes if items is undefined
   ```
   
   ✅ GOOD:
   ```tsx
   const items = data?.items ?? [];
   if (items.length === 0) {
     return <EmptyState message={t("noItems")} />;
   }
   return items.map(item => <div key={item.id}>{item.name}</div>);
   ```

3. **Loading and Error States**
   - **ALWAYS** handle `isLoading` state from TanStack Query hooks.
   - **ALWAYS** handle `isError` or error states.
   - **ALWAYS** show loading skeletons/spinners during data fetching.
   - **ALWAYS** show error messages with retry options when requests fail.
   
   ✅ GOOD Pattern:
   ```tsx
   const { data, isLoading, isError, error } = useQuery(...);
   
   if (isLoading) {
     return <Skeleton />;
   }
   
   if (isError) {
     return <ErrorState error={error} onRetry={() => refetch()} />;
   }
   
   const items = data?.data ?? [];
   if (items.length === 0) {
     return <EmptyState />;
   }
   
   return <ItemList items={items} />;
   ```

4. **Type Safety with Default Values**
   - Extract nested data with defaults at the top of component.
   - Use type-safe defaults that match the expected structure.
   - Make types optional (`?`) in `.d.ts` files if properties can be undefined at runtime.
   
   ✅ GOOD Pattern:
   ```tsx
   const overview = data?.data;
   if (!overview) return null;
   
   // Extract with defaults
   const deals = overview.deals ?? {
     total_deals: 0,
     open_deals: 0,
     won_deals: 0,
     lost_deals: 0,
     total_value: 0,
     total_value_formatted: "Rp 0",
     change_percent: 0,
   };
   
   const revenue = overview.revenue ?? {
     total_revenue: 0,
     total_revenue_formatted: "Rp 0",
     change_percent: 0,
   };
   
   // Now safe to use
   <div>{deals.total_deals}</div>
   <div>{formatCurrency(revenue.total_revenue)}</div>
   ```

5. **Defensive Programming for API Responses**
   - **NEVER** assume API responses match TypeScript types exactly.
   - TypeScript types are compile-time only; runtime data may differ.
   - Always validate and provide fallbacks for:
     - Missing properties
     - Null/undefined values
     - Wrong data types
     - Empty arrays/objects
   
   ✅ GOOD:
   ```tsx
   // In types/index.d.ts - make optional if can be undefined
   export interface DashboardOverview {
     deals?: { total_deals: number; ... };
     revenue?: { total_revenue: number; ... };
   }
   
   // In component - always check
   const deals = overview.deals ?? DEFAULT_DEALS;
   ```

6. **Empty States and Placeholders**
   - **ALWAYS** show meaningful empty states, not just blank screens.
   - Use translation keys for empty state messages.
   - Provide helpful context (e.g., "No tasks found. Create one to get started.").
   
   ✅ GOOD:
   ```tsx
   if (tasks.length === 0) {
     return (
       <Card>
         <CardContent className="text-center py-8">
           <p className="text-sm text-muted-foreground">{t("empty")}</p>
           <Button onClick={onCreate}>{t("createFirst")}</Button>
         </CardContent>
       </Card>
     );
   }
   ```

7. **Safe String/Number Operations**
   - **ALWAYS** handle undefined/null for string operations (`.toLocaleString()`, `.toUpperCase()`, etc.).
   - **ALWAYS** provide defaults for number operations (division, formatting, etc.).
   
   ✅ GOOD:
   ```tsx
   const value = deal.value ?? 0;
   const formatted = value.toLocaleString("id-ID");
   
   const name = user.name ?? "";
   const displayName = name.toUpperCase();
   ```

8. **Safe Date Operations**
   - **ALWAYS** validate dates before formatting.
   - Handle invalid dates gracefully.
   
   ✅ GOOD:
   ```tsx
   const formatDate = (value?: string | null) => {
     if (!value) return t("noDate");
     const date = new Date(value);
     if (isNaN(date.getTime())) return t("invalidDate");
     return date.toLocaleDateString(locale, { ... });
   };
   ```

9. **Component Props Safety**
   - Use `readonly` for props to prevent mutations.
   - Provide default props when appropriate.
   - Validate required props exist before using.
   
   ✅ GOOD:
   ```tsx
   interface ComponentProps {
     readonly data?: DataType;
     readonly onAction?: () => void;
   }
   
   export function Component({ data, onAction }: ComponentProps) {
     const safeData = data ?? DEFAULT_DATA;
     // ...
   }
   ```

10. **Error Boundaries**
    - Use Error Boundaries for component-level error handling.
    - Provide fallback UI when components crash.
    - Log errors for debugging but show user-friendly messages.
    
    ✅ GOOD:
    ```tsx
    <ErrorBoundary fallback={<ErrorFallback />}>
      <DashboardOverview />
    </ErrorBoundary>
    ```

**Checklist Before Committing Component Code:**
- [ ] All nested property accesses use optional chaining (`?.`)
- [ ] All arrays checked for existence and length before iteration
- [ ] Loading states handled with skeletons/spinners
- [ ] Error states handled with user-friendly messages
- [ ] Empty states provide helpful context
- [ ] Default values provided for all potentially undefined data
- [ ] Type definitions match runtime reality (optional properties marked with `?`)
- [ ] Date operations validate input
- [ ] String/Number operations handle null/undefined
- [ ] Component tested with missing/undefined data

Smart Suspense usage (Next.js App Router)
- Prioritize static/above-the-fold UI:
  - Use route-level `loading.tsx` for coarse skeletons.
  - Wrap only truly async subtrees in `Suspense` with lightweight fallbacks.
- Prefer multiple small Suspense boundaries over one large boundary.
- Do not suspend global layout chrome; suspend leaf/async components instead.
- For lists, show static shell (headers, filters) immediately; suspend the data region.
- Combine with `error.tsx` for graceful failures; never block the entire page for one widget.

Backend Standards (Go + Gin)
- Use layered architecture: Handler → Service → Repository.
- Use dependency injection pattern (constructor-based).
- Use interface-based design for repositories.
- Follow API response standards from `/docs/api-standart/`.
- All errors must use error codes from `/docs/api-standart/api-error-codes.md`.
- **CRITICAL**: When adding/modifying backend endpoints:
  1. Update Postman collection: `/docs/postman/CRM-Healthcare-API.postman_collection.json`
  2. Update Postman documentation if needed: `/docs/postman/README.md` or `/docs/postman/SETUP.md`
  3. Test with Postman before marking as complete.

Sprint Management
- **CRITICAL**: When completing sprint tasks:
  1. Mark completed tasks in `/docs/SPRINT_PLANNING.md` with `[x]`
  2. Update acceptance criteria status if applicable
  3. Document any deviations or additional work done
- Do NOT create separate completion documents. Update `SPRINT_PLANNING.md` directly.

Naming & conventions
- Kebab-case directories, PascalCase components, camelCase functions/variables.
- Each folder can have an `index.ts` barrel only when it improves DX and tree-shaking.
- Keep files short and cohesive; extract when a file grows beyond one responsibility.

Component Logic Separation Examples

❌ BAD - Logic in component:
```tsx
export function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  
  const handleSubmit = async () => {
    // Business logic in component - BAD!
    const response = await authService.login({ email, password });
    if (response.success) {
      useAuthStore.getState().setUser(response.data.user);
      router.push("/dashboard");
    }
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

✅ GOOD - Logic in hook:
```tsx
// hooks/useLogin.ts
export function useLogin() {
  const router = useRouter();
  const { login } = useAuthStore();
  
  return useMutation({
    mutationFn: (data: LoginFormData) => login(data.email, data.password),
    onSuccess: () => router.push("/dashboard"),
  });
}

// components/login-form.tsx
export function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });
  const { mutate: login, isPending } = useLogin();
  
  return <form onSubmit={handleSubmit((data) => login(data))}>...</form>;
}
```
